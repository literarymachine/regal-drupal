<?php
/**
 * Copyright 2013 hbz NRW (http://www.hbz-nrw.de/)
 *
 * This file is part of regal-drupal.
 *
 * regal-drupal is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * regal-drupal is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with regal-drupal.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * Implementation of the field storage API for Edoweb Storage.
 */

/**
* Implement hook_menu().
* Settings for edoweb_storage are configured here.
*/
function edoweb_storage_menu() {
  $items = array();
  $items['edoweb/config/storage'] = array(
    'title' => 'Storage',
    'description' => 'Configuration for the Edoweb Storage module.',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('edoweb_storage_configuration_form'),
    'access arguments' => array('administer edoweb configuration'),
    'type' => MENU_NORMAL_ITEM,
  );

 return $items;
}

/**
* Create and display the configuration settings form.
*/
function edoweb_storage_configuration_form($form, &$form_state) {

  // Text field for api host.
  $form['edoweb_api_host'] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get(
      'edoweb_api_host',
      'api.localhost'
    ),
    '#title' => t('API host'),
    '#description' => t('The hostname or IP address of the API, without leading http://'),
    '#size' => 40,
    '#maxlength' => 120,
    '#required' => TRUE,
  );

  // Text field for api user.
  $form['edoweb_api_user'] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get(
      'edoweb_api_user',
      'admin'
    ),
    '#title' => t('API user'),
    '#description' => t('The username to authorize with.'),
    '#size' => 40,
    '#maxlength' => 120,
    '#required' => TRUE,
  );

  // Password field for api password.
  $form['edoweb_api_password'] = array(
    '#type' => 'password',
    '#default_value' => variable_get(
      'edoweb_api_password',
      'admin'
    ),
    '#title' => t('API password'),
    '#description' => t('The password to authorize with.'),
    '#size' => 40,
    '#maxlength' => 120,
    '#required' => TRUE,
  );

  // Text field for api namespace.
  $form['edoweb_api_namespace'] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get(
      'edoweb_api_namespace',
      'edoweb'
    ),
    '#title' => t('Namespace'),
    '#description' => t('The namespace of the primary resources.'),
    '#size' => 40,
    '#maxlength' => 120,
    '#required' => TRUE,
  );

  // Text field for lobid api host.
  $form['edoweb_lobid_host'] = array(
    '#type' => 'textfield',
    '#default_value' => variable_get(
      'edoweb_lobid_host',
      'api.lobid.org'
    ),
    '#title' => t('lobid API host'),
    '#description' => t('The hostname or IP address of the lobid API, without leading http://'),
    '#size' => 40,
    '#maxlength' => 120,
    '#required' => TRUE,
  );

  // Checkbox for debugging mode
  $form['edoweb_api_debug'] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('edoweb_api_debug'),
    '#title' => t('Show debugging output'),
  );

  // Checkbox to disable caching
  $form['edoweb_api_nocache'] = array(
    '#type' => 'checkbox',
    '#default_value' => variable_get('edoweb_api_nocache'),
    '#title' => t('Disable caching'),
  );

  // Additional submit handler to reset caches
  $form['#submit'][] = 'edoweb_storage_configuration_form_submit';

  return system_settings_form($form);
}

function edoweb_storage_configuration_form_submit($form, &$form_state) {
  $api_host_changed = !(variable_get('edoweb_api_host')
    == $form_state['values']['edoweb_api_host']);
  $namespace_changed = !(variable_get('edoweb_api_namespace')
    == $form_state['values']['edoweb_api_namespace']);
  if ($api_host_changed || $namespace_changed) {
    cache_clear_all('*', 'cache_field', TRUE);
    db_truncate('edoweb_basic')->execute();
    drupal_set_message('Entity caches cleared');
  }
}

/**
 * Implements hook_field_storage_info().
 */
function edoweb_storage_field_storage_info() {
  return array(
    'edoweb_storage' => array(
      'label' => t('Edoweb Storage field storage'),
      'description' => t('Stores nodes and fields in a Edoweb Storage database.'),
    ),
  );
}

/**
 * Implements hook_field_storage_details().
 */
function edoweb_storage_field_storage_details($field) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_field_storage_create_field().
 */
function edoweb_storage_field_storage_create_field($field) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_field_storage_update_field().
 */
function edoweb_storage_field_storage_update_field($field, $prior_field, $has_data) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_field_storage_delete_field().
 */
function edoweb_storage_field_storage_delete_field($field) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_field_storage_load().
 */
function edoweb_storage_field_storage_load($entity_type, $entities, $age, $fields, $options) {
  $api = new EdowebAPIClient();
  foreach ($entities as $entity) {
    $api->load($entity);
  }
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_field_storage_write().
 */
function edoweb_storage_field_storage_write($entity_type, $entity, $op, $fields, $entity_write = FALSE) {
  $api = new EdowebAPIClient();
  $api->save($entity);
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}


/**
 * Implement hook_field_storage_delete().
 *
 */
function edoweb_storage_field_storage_delete($entity_type, $entity, $fields) {
  $api = new EdowebAPIClient();
  $api->delete($entity);
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implement hook_field_storage_delete_revision().
 *
 */
function edoweb_storage_field_storage_delete_revision($entity_type, $entity, $fields) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implement hook_field_storage_delete_instance().
 *
 */
function edoweb_storage_field_storage_delete_instance($instance) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

class EdowebStorageException extends Exception {}

/**
 * Implements hook_entity_query_alter().
 *
 * Alter the entity info.
 */
function edoweb_storage_entity_query_alter($query) {
  if (isset($query->tags['elasticsearch'])
      || isset($query->tags['lobid'])
  ) {
    $query->executeCallback = '_edoweb_storage_query';
  }
}

function _edoweb_storage_query($query) {
  $api = new EdowebAPIClient();
  return $api->query($query);
}

/**
 * Implements hook_field_storage_query().
 *
 */
function edoweb_storage_field_storage_query($query) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_field_attach_rename_bundle().
 */
function edoweb_storage_field_attach_rename_bundle($entity_type, $bundle_old, $bundle_new) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_entity_insert().
 */
function edoweb_storage_entity_insert($entity, $entity_type) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_entity_update().
 */
function edoweb_storage_entity_update($entity, $entity_type) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_field_attach_delete.
 */
function edoweb_storage_field_attach_delete($entity_type, $entity) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

/**
 * Implements hook_entity_info_alter().
 */
function edoweb_storage_entity_info_alter(&$entity_info) {
  __devnulldb_log(__FUNCTION__ . " called\n");
  __devnulldb_log("arguments: " . print_r(func_get_args(), TRUE) . "\n");
  return;
}

function __devnulldb_log($message, $target='php://stderr') {
  //file_put_contents($target, $message);
}

/*************************
 * Edoweb helper functions
 *************************/

define('EDOWEB_ENTITY_TYPE', 'edoweb_basic');

function _edoweb_storage_entity_serialize_turtle(
  $entity, $metadata_types = array()
){
  $rdf_serializer = new LibRDF_Serializer('turtle');
  return _edoweb_storage_entity_serialize_rdf(
    $entity, $rdf_serializer, $metadata_types
  );
}

function _edoweb_storage_entity_serialize_ntriples(
  $entity, $metadata_types = array()
){
  $rdf_serializer = new LibRDF_Serializer('ntriples');
  return _edoweb_storage_entity_serialize_rdf(
    $entity, $rdf_serializer, $metadata_types
  );
}

function _edoweb_storage_entity_serialize_rdf(
  $entity, $rdf_serializer = false, $metadata_types = array()
){
  $rdf_model = new LibRDF_Model(new LibRDF_Storage());
  $rdf_mapping = rdf_mapping_load(
    EDOWEB_ENTITY_TYPE, _edoweb_storage_entity_get_bundle($entity)
  );
  // First element contains the rdf:type definitions
  $rdf_type_predicate = new LibRDF_URINode(
    'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
  );
  $rdf_subject = new LibRDF_URINode($entity->identifier());
  foreach (array_shift($rdf_mapping) as $rdf_type_mapping) {
    $rdf_type_statement = new LibRDF_Statement(
      $rdf_subject, $rdf_type_predicate,
      new LibRDF_URINode(_edoweb_expand_curie($rdf_type_mapping))
    );
    $rdf_model->addStatement($rdf_type_statement);
  }

  // Add non-field properties
  $rdf_about_subject = new LibRDF_URINode(
    substr($rdf_subject, 1, -1) .  '.rdf'
  );
  $rdf_model->addStatement(
    new LibRDF_Statement(
      $rdf_about_subject,
      new LibRDF_URINode(_edoweb_expand_curie('dce:creator')),
      new LibRDF_LiteralNode($entity->uid)
    )
  );

  $wrapper = entity_metadata_wrapper(EDOWEB_ENTITY_TYPE, $entity);
  // Following elements contain predicate mappings
  foreach ($rdf_mapping as $field_name => $field_mapping) {
    $field_info = field_info_field($field_name);

    $handler_settings = array_key_exists(
      'handler_settings', $field_info['settings']
    ) ? $field_info['settings']['handler_settings']
      : false;

    $embedded_storage = $handler_settings && array_key_exists(
      'embedded_storage', $handler_settings
    ) ? $handler_settings['embedded_storage']
      : false;

    $metadata_type = $field_info['settings']['metadata_type'];
    if (!empty($metadata_types)
        && !in_array($metadata_type, $metadata_types)) {
      continue;
    }
    $rdf_predicate = new LibRDF_URINode(
      _edoweb_expand_curie($field_mapping['predicates'][0])
    );
    $rdf_subject = _get_rdf_subject($entity, $field_name);
    try {
      $items = $wrapper->{$field_name}->value();
    } catch (EntityMetadataWrapperException $e) {
      // Field is not available for this entity
      continue;
    }
    if (is_null($items) || empty($items)) {
      // Field is available for this entity,
      // but does not have value(s).
      continue;
    }
    if (!is_array($items)) {
      $items = array($items);
    }
    foreach ($items as $item) {
      if (isset($field_mapping['type'])
          and $field_mapping['type'] == 'rel') {
        if (is_object($item)) {
          $rdf_object = new LibRDF_URINode($item->identifier());
          if ($embedded_storage) {
            $embedded_item_graph = _edoweb_storage_entity_serialize_rdf(
              $item, false, $metadata_types
            );
            foreach ($embedded_item_graph as $embedded_item_statement) {
              $rdf_model->addStatement($embedded_item_statement);
            }
          }
        } else {
          $rdf_object = new LibRDF_URINode($item);
          if ($embedded_storage) {
            $embedded_item_graph = _edoweb_storage_entity_serialize_rdf(
              edoweb_basic_load($item), false, $metadata_types
            );
            foreach ($embedded_item_graph as $embedded_item_statement) {
              $rdf_model->addStatement($embedded_item_statement);
            }
          }
        }
      } else {
        $rdf_object = new LibRDF_LiteralNode($item);
      }
      $rdf_statement = new LibRDF_Statement(
        $rdf_subject, $rdf_predicate, $rdf_object
      );
      $rdf_model->addStatement($rdf_statement);
    }
  }
  if ($rdf_serializer) {
    foreach (rdf_get_namespaces() as $prefix => $namespace) {
      $rdf_serializer->setNamespace($namespace, $prefix);
    }
    return $rdf_model->serializeStatements($rdf_serializer);
  } else {
    return $rdf_model;
  }
}

function _edoweb_storage_entity_deserialize_rdf($entity, $rdf_data, $rdf_parser) {
  $rdf_mapping = rdf_mapping_load(
    EDOWEB_ENTITY_TYPE, _edoweb_storage_entity_get_bundle($entity)
  );
  $rdf_model = new LibRDF_Model(new LibRDF_Storage());
  try {
    $rdf_model->loadStatementsFromString($rdf_parser, $rdf_data);
  } catch (LibRDF_Error $e) {
    // TODO: log errors
    // drupal_set_message($e->getMessage(), 'error');
  }
  LibRDF_LiteralNode::setPlainOutput(true);

  $entity->setSource($rdf_model);

  // Skip first element, these are the rdf:type definitions
  unset($rdf_mapping[key($rdf_mapping)]);
  $wrapper = entity_metadata_wrapper(EDOWEB_ENTITY_TYPE, $entity);
  foreach ($rdf_mapping as $field_name => $mapping) {
    $rdf_predicate = new LibRDF_URINode(
      _edoweb_expand_curie($mapping['predicates'][0])
    );
    // Modify subject URI for datastream metadata
    $rdf_subject = _get_rdf_subject($entity, $field_name);
    foreach ($rdf_model->getTargets($rdf_subject, $rdf_predicate) as $value) {
      try {
        if ($value instanceOf LibRDF_LiteralNode) {
          // Fix escaped unicode characters such as \u00E4
          $value = json_decode('"'.$value.'"');
          if ($wrapper->{$field_name} instanceOf EntityValueWrapper) {
            $wrapper->{$field_name} = (string) $value;
          } else {
            $wrapper->{$field_name}[] = (string) $value;
          }
        } else {
          $value = substr($value, 1, -1);
          if ($wrapper->{$field_name} instanceOf EntityValueWrapper) {
            $wrapper->{$field_name} = $value;
          } else {
            $wrapper->{$field_name}[] = $value;
          }
        }
        //drupal_set_message("Populated $field_name.");
      } catch (EntityMetadataWrapperException $e) {
        //drupal_set_message($e->getMessage(), 'error');
      }
    }
  }
  // Add non-field properties
  $rdf_about_subject = new LibRDF_URINode("{$entity->identifier()}.rdf");
  try {
    $entity->updated = strtotime($rdf_model->getTarget(
        $rdf_about_subject,
        new LibRDF_URINode(_edoweb_expand_curie('dc:modified'))
    ));
  } catch (LibRDF_LookupError $e) {
    // No update time available, ignore
  }

}

function _get_rdf_subject($entity, $field_name) {
  $rdf_subject = $entity->identifier();

  $datastream_properties = array(
    'field_edoweb_filetype',
    'field_edoweb_label',
    'field_edoweb_filesize',
  );

  if ('file' == $entity->bundle_type
      && in_array($field_name, $datastream_properties)
  ) {
    return new LibRDF_URINode("$rdf_subject/data");
  } else {
    return new LibRDF_URINode($rdf_subject);
  }

}

function _edoweb_storage_entity_get_bundle($entity) {
  $entity_ids = entity_extract_ids(EDOWEB_ENTITY_TYPE, $entity);
  return $entity_ids[2];
}

function _edoweb_storage_entity_serialize_jsonld(
  $entity, $metadata_types = array()
){
  $rdf_mapping = rdf_mapping_load(
    EDOWEB_ENTITY_TYPE, _edoweb_storage_entity_get_bundle($entity)
  );
  $jsonld_context = new stdClass();
  $rdf_namespaces = rdf_get_namespaces();
  foreach ($rdf_namespaces as $prefix => $uri) {
    $jsonld_context->{$prefix} = $uri;
  }
  $rdf_subject = new LibRDF_URINode($entity->identifier());
  $rdf_serializer = new LibRDF_Serializer('ntriples');
  $rdf_ntriples = _edoweb_storage_entity_serialize_rdf(
    $entity, $rdf_subject, $rdf_serializer, $metadata_types
  );
  try {
    $rdf_jsonld = jsonld_compact(jsonld_from_rdf($rdf_ntriples), $jsonld_context);
  } catch (JsonLdException $e) {
    // drupal_set_message("Error reading ntriples\n$rdf_ntriples");
    $rdf_jsonld = null;
  }
  return str_replace('\\/', '/', json_encode($rdf_jsonld));
}

function _edoweb_storage_entity_deserialize_jsonld($entity, $rdf_data) {
  $options = array();
  $options['format'] = 'application/nquads';
  $rdf_ntriples = jsonld_to_rdf(json_decode($rdf_data), $options);
  /*
   * jsonld_to_rdf returns N-Triples in utf-8, but currently
   * LibRDF expects ASCII with utf-8 hex values.
   */
  $rdf_ntriples = _edoweb_escape_utf8($rdf_ntriples);
  $rdf_parser = new LibRDF_Parser('ntriples');
  return _edoweb_storage_entity_deserialize_rdf($entity, $rdf_ntriples, $rdf_parser);
}

function _edoweb_escape_utf8($string) {
  $char_map = array(
    '¢' => '\u00A2',
    '£' => '\u00A3',
    '€' => '\u20AC',
    '¥' => '\u00A5',
    '°' => '\u00B0',
    '¼' => '\u00BC',
    'Œ' => '\u0152',
    '½' => '\u00BD',
    'œ' => '\u0153',
    '¾' => '\u00BE',
    'Ÿ' => '\u0178',
    '¡' => '\u00A1',
    '«' => '\u00AB',
    '»' => '\u00BB',
    '¿' => '\u00BF',
    'À' => '\u00C0',
    'Á' => '\u00C1',
    'Â' => '\u00C2',
    'Ã' => '\u00C3',
    'Ä' => '\u00C4',
    'Å' => '\u00C5',
    'Æ' => '\u00C6',
    'Ç' => '\u00C7',
    'È' => '\u00C8',
    'É' => '\u00C9',
    'Ê' => '\u00CA',
    'Ë' => '\u00CB',
    'Ì' => '\u00CC',
    'Í' => '\u00CD',
    'Î' => '\u00CE',
    'Ï' => '\u00CF',
    'Ð' => '\u00D0',
    'Ñ' => '\u00D1',
    'Ò' => '\u00D2',
    'Ó' => '\u00D3',
    'Ô' => '\u00D4',
    'Õ' => '\u00D5',
    'Ö' => '\u00D6',
    'Ø' => '\u00D8',
    'Ù' => '\u00D9',
    'Ú' => '\u00DA',
    'Û' => '\u00DB',
    'Ü' => '\u00DC',
    'Ý' => '\u00DD',
    'Þ' => '\u00DE',
    'ß' => '\u00DF',
    'à' => '\u00E0',
    'á' => '\u00E1',
    'â' => '\u00E2',
    'ã' => '\u00E3',
    'ä' => '\u00E4',
    'å' => '\u00E5',
    'æ' => '\u00E6',
    'ç' => '\u00E7',
    'è' => '\u00E8',
    'é' => '\u00E9',
    'ê' => '\u00EA',
    'ë' => '\u00EB',
    'ì' => '\u00EC',
    'í' => '\u00ED',
    'î' => '\u00EE',
    'ï' => '\u00EF',
    'ð' => '\u00F0',
    'ñ' => '\u00F1',
    'ò' => '\u00F2',
    'ó' => '\u00F3',
    'ô' => '\u00F4',
    'õ' => '\u00F5',
    'ö' => '\u00F6',
    'ø' => '\u00F8',
    'ù' => '\u00F9',
    'ú' => '\u00FA',
    'û' => '\u00FB',
    'ü' => '\u00FC',
    'ý' => '\u00FD',
    'þ' => '\u00FE',
    'ÿ' => '\u00FF',
  );
  return strtr($string, $char_map);
}

function _edoweb_expand_curie($curie) {
  if ('http://' == substr($curie, 0, 7)
      || 'local:' == substr($curie, 0, 6)
      || '_:' == substr($curie, 0, 2)
  ) {
    return $curie;
  }
  $rdf_namespaces = rdf_get_namespaces();
  list($curie_prefix, $curie_local) = explode(':', $curie);
  if ($curie_prefix == 'ddc') {
    $curie_local .= '/';
  }
  return $rdf_namespaces[$curie_prefix] . $curie_local;
}

function _edoweb_compact_uri($uri) {
  $rdf_namespaces = rdf_get_namespaces();
  $split = strrpos($uri, '#');
  if (!$split) {
    $split = strrpos($uri, '/');
  }
  // Trailing slash
  if ($split == strlen($uri) - 1) {
    $split = strrpos($uri, '/', $split - strlen($uri) - 1);
  }
  $curie_prefix = array_search(
    substr($uri, 0, $split + 1), $rdf_namespaces
  );
  $curie_local = substr($uri, $split + 1);
  if (!$curie_prefix) {
    return $uri;
  } else {
    return "$curie_prefix:$curie_local";
  }
}

function _edoweb_bundle_type_from_rdf($remote_id, $rdf_data) {
  LibRDF_LiteralNode::setPlainOutput(true);
  // If all fails, resort to generic bundle
  $bundle_type = 'generic';
  try {
    // Regal content-types overrule RDF types
    $bundle_type = (string) $rdf_data->getTarget(
      new LibRDF_URINode($remote_id),
      new LibRDF_URINode('http://hbz-nrw.de/regal#contentType')
    );
  } catch (LibRDF_LookupError $e) {
    try {
      // Determine bundle based on RDF type
      $rdf_types = $rdf_data->getTargets(
        new LibRDF_URINode(_edoweb_expand_curie($remote_id)),
        new LibRDF_URINode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type')
      );
      foreach ($rdf_types as $rdf_type) {
        $type = _edoweb_compact_uri(substr($rdf_type, 1, -1));
        foreach (edoweb_rdf_types() as $bundle => $types) {
          if (in_array($type, $types)) {
            return $bundle;
          }
        }
      }
    } catch (LibRDF_LookupError $e) {
    }
  }
  return $bundle_type;
}
